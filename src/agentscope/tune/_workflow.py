# -*- coding: utf-8 -*-
"""Basic concepts for agentscope tuner.

Workflow: An agent workflow function type for tuning.

Args:
    task (Dict):
        The task information for the workflow run.
    model (ChatModelBase):
        The primary chat model used in the workflow, this is the main model
        being tuned.
    auxiliary_models (Dict[str, ChatModelBase]):
        A dictionary of additional chat models available for LLM-as-a-Judge
        usage. The keys are model names, and the values are the corresponding
        ChatModelBase instances. Note that these auxiliary models are not tuned
        during the workflow.
Returns:
    Union[float, Dict]:
        The reward obtained from the workflow function.


Judge: A judge function type for tuning.

Args:
    task (Dict):
        The task information for the corresponding workflow.
    model_response (Dict):
        The response generated by the corresponding workflow.
    auxiliary_models (Dict[str, ChatModelBase]):
        A dictionary of additional chat models available for LLM-as-a-Judge
        usage. The keys are model names, and the values are the corresponding
        ChatModelBase instances.
Returns:
    float:
        The reward value assigned by the judge function.
"""

from typing import (
    Dict,
    Callable,
    Awaitable,
    Union,
    Optional,
    get_type_hints,
    get_args,
    get_origin,
)

import inspect

from .._logging import logger
from ..model import ChatModelBase


WorkflowType = Callable[
    [Dict, ChatModelBase, Dict[str, ChatModelBase]],
    Awaitable[Union[float, Dict]],
]


JudgeType = Callable[[Dict, Dict, Dict[str, ChatModelBase]], Awaitable[float]]


def _is_type_compatible(
    actual_type: Optional[type],
    expected_type: Optional[type],
) -> bool:
    """Check if actual_type is compatible with expected_type.

    Args:
        actual_type: The actual type annotation from the function
        expected_type: The expected type we're checking against

    Returns:
        bool: True if types are compatible
    """
    result = False

    if actual_type is None:
        return result

    if actual_type == expected_type:
        result = True
    else:
        actual_origin = get_origin(actual_type)
        expected_origin = get_origin(expected_type)

        if actual_origin is not None and expected_origin is not None:
            if actual_origin == expected_origin:
                actual_args = get_args(actual_type)
                expected_args = get_args(expected_type)
                if not actual_args and not expected_args:
                    result = True
                elif len(actual_args) == len(expected_args):
                    result = all(
                        _is_type_compatible(actual_arg, expected_arg)
                        for actual_arg, expected_arg in zip(
                            actual_args,
                            expected_args,
                        )
                    )
            # else: result remains False
        elif actual_origin is not None and expected_origin is None:
            result = False
        elif actual_origin is None and expected_origin is not None:
            result = False
        else:
            try:
                if inspect.isclass(actual_type) and inspect.isclass(
                    expected_type,
                ):
                    result = issubclass(actual_type, expected_type)
            except TypeError:
                # issubclass() arg 1 must be a class
                result = False

    return result


def _validate_function_signature(func: Callable) -> bool:
    """Validate if a function matches the workflow type signature.

    Args:
        func (Callable): The function to validate.
    """
    # check if the function is asynchronous
    if not inspect.iscoroutinefunction(func):
        logger.warning("The function is not asynchronous.")
        return False

    # Define expected parameter types and return type manually
    expected_params = [
        ("task", Dict),
        ("model", ChatModelBase),
        ("auxiliary_models", Dict[str, ChatModelBase]),
    ]
    expected_return = float

    func_signature = inspect.signature(func)
    func_hints = get_type_hints(func)

    # Check if the number of parameters matches
    if len(func_signature.parameters) != len(expected_params):
        logger.warning(
            "Expected %d parameters, but got %d",
            len(expected_params),
            len(func_signature.parameters),
        )
        return False

    # Validate each parameter's name and type
    for (param_name, _), (expected_name, expected_type) in zip(
        func_signature.parameters.items(),
        expected_params,
    ):
        actual_type = func_hints.get(param_name)

        if param_name != expected_name:
            logger.warning(
                "Expected parameter name %s, but got %s",
                expected_name,
                param_name,
            )
            return False

        if not _is_type_compatible(actual_type, expected_type):
            logger.warning(
                "Expected parameter %s of type %s, but got %s of type %s",
                expected_name,
                expected_type,
                param_name,
                actual_type,
            )
            return False

    # Validate the return type
    return_annotation = func_hints.get("return", None)
    if not _is_type_compatible(return_annotation, expected_return):
        logger.warning(
            "Expected return type %s, but got %s",
            expected_return,
            return_annotation,
        )
        return False

    return True
